/**
 * Specialized Vulnerability Scanner Tests
 * 
 * This script tests the vulnerability scanner microservice in more detail,
 * including CVE detection, dependency scanning, and port scanning.
 */

const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');

// Configuration
const config = {
  baseUrl: process.env.BASE_URL || 'http://localhost',
  vulnerabilityScanner: {
    port: 3002,
    endpoint: '/api/vulnerability-scanner'
  },
  testVulnerabilities: [
    {
      name: 'CVE-2021-44228', // Log4Shell
      description: 'Critical vulnerability in Log4j',
      severity: 'CRITICAL'
    },
    {
      name: 'CVE-2022-22965', // Spring4Shell
      description: 'Remote code execution in Spring Framework',
      severity: 'HIGH'
    },
    {
      name: 'CVE-2023-12345', // Fictional test CVE
      description: 'Test vulnerability for detection checks',
      severity: 'MEDIUM'
    }
  ],
  timeout: 10000
};

// Test utilities
const testUtil = {
  formatResult: (testName, success, error = null) => {
    const status = success ? '✅ PASSED' : '❌ FAILED';
    console.log(`${status}: ${testName}`);
    if (error) {
      console.error(`  Error: ${error.message || error}`);
    }
    return { success, error };
  },

  createApiClient: () => {
    const { vulnerabilityScanner } = config;
    return axios.create({
      baseURL: `${config.baseUrl}${vulnerabilityScanner.endpoint || `:${vulnerabilityScanner.port}`}`,
      timeout: config.timeout
    });
  },
  
  // Create a temporary test file with a known vulnerability pattern
  createTestVulnerabilityFile: async () => {
    const testDir = path.join(__dirname, 'test-artifacts');
    const filePath = path.join(testDir, 'vulnerable-test-app.json');
    
    const vulnerablePackageJson = {
      name: "vulnerable-test-app",
      version: "1.0.0",
      dependencies: {
        "log4j": "2.14.0", // Vulnerable version for Log4Shell
        "spring-framework": "5.3.17", // Vulnerable version for Spring4Shell
        "other-package": "1.0.0"
      }
    };
    
    try {
      // Create the test directory if it doesn't exist
      await fs.mkdir(testDir, { recursive: true });
      
      // Write the test file
      await fs.writeFile(filePath, JSON.stringify(vulnerablePackageJson, null, 2));
      
      return filePath;
    } catch (error) {
      console.error('Error creating test vulnerability file:', error);
      throw error;
    }
  },
  
  // Clean up test files after tests
  cleanupTestFiles: async () => {
    const testDir = path.join(__dirname, 'test-artifacts');
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      console.error('Error cleaning up test files:', error);
    }
  }
};

// Test functions
async function testVulnerabilityServiceHealth() {
  console.log('\n=== Vulnerability Scanner Health Test ===\n');
  const results = {};
  
  try {
    console.log('Testing vulnerability scanner health...');
    const client = testUtil.createApiClient();
    const response = await client.get('/health');
    
    const status = response.data.status || 'unknown';
    const isHealthy = status === 'healthy' || status === 'ok';
    
    results['health_check'] = testUtil.formatResult(
      'Vulnerability scanner health check',
      isHealthy,
      isHealthy ? null : `Service returned status: ${status}`
    );
  } catch (error) {
    results['health_check'] = testUtil.formatResult(
      'Vulnerability scanner health check',
      false,
      error
    );
  }
  
  return results;
}

async function testBasicScan() {
  console.log('\n=== Basic Vulnerability Scan Test ===\n');
  const results = {};
  
  try {
    console.log('Testing basic vulnerability scan...');
    const client = testUtil.createApiClient();
    const scanParams = {
      target: 'test-service',
      scope: 'basic',
      options: {
        port_scan: true,
        dependency_check: true
      }
    };
    
    const response = await client.post('/scan', scanParams);
    
    // Check if the scan was initiated or completed
    const scanStarted = response.status === 200 || response.status === 202;
    const scanIdPresent = response.data && response.data.scan_id;
    
    results['basic_scan'] = testUtil.formatResult(
      'Basic vulnerability scan',
      scanStarted && scanIdPresent,
      (!scanStarted || !scanIdPresent) ? 'Scan should return a scan ID' : null
    );
    
    // If we got a scan ID, store it for later use
    if (scanIdPresent) {
      results.scan_id = response.data.scan_id;
    }
  } catch (error) {
    results['basic_scan'] = testUtil.formatResult(
      'Basic vulnerability scan',
      false,
      error
    );
  }
  
  return results;
}

async function testScanResults(scanId) {
  console.log('\n=== Scan Results Test ===\n');
  const results = {};
  
  // If no scan ID, we can't check results
  if (!scanId) {
    results['scan_results'] = testUtil.formatResult(
      'Retrieve scan results',
      false,
      'No scan ID available to check results'
    );
    return results;
  }
  
  try {
    console.log(`Testing retrieval of scan results for scan ID: ${scanId}...`);
    const client = testUtil.createApiClient();
    
    // We might need to wait for scan completion
    let scanComplete = false;
    let attempts = 0;
    let response;
    
    while (!scanComplete && attempts < 5) {
      response = await client.get(`/scan/${scanId}`);
      
      scanComplete = response.data.status === 'completed';
      
      if (!scanComplete) {
        console.log(`Scan in progress (${response.data.status}), waiting 2 seconds...`);
        await new Promise(resolve => setTimeout(resolve, 2000));
        attempts++;
      }
    }
    
    results['scan_results'] = testUtil.formatResult(
      'Retrieve scan results',
      scanComplete,
      scanComplete ? null : 'Scan did not complete in expected time'
    );
    
    // If we have results, check if they have the expected format
    if (scanComplete && response.data.results) {
      const hasExpectedFormat = 
        Array.isArray(response.data.results.vulnerabilities) &&
        'timestamp' in response.data;
      
      results['results_format'] = testUtil.formatResult(
        'Scan results format check',
        hasExpectedFormat,
        hasExpectedFormat ? null : 'Results should have expected format'
      );
    }
  } catch (error) {
    results['scan_results'] = testUtil.formatResult(
      'Retrieve scan results',
      false,
      error
    );
  }
  
  return results;
}

async function testFileBasedScan() {
  console.log('\n=== File-Based Vulnerability Scan Test ===\n');
  const results = {};
  let testFilePath = null;
  
  try {
    // Create a test file with known vulnerabilities
    testFilePath = await testUtil.createTestVulnerabilityFile();
    console.log(`Created test vulnerability file at: ${testFilePath}`);
    
    // Now scan the file
    const client = testUtil.createApiClient();
    const scanParams = {
      target_type: 'file',
      target_path: testFilePath,
      scope: 'dependencies',
      options: {
        package_scan: true
      }
    };
    
    const response = await client.post('/scan/dependencies', scanParams);
    
    // Check if the scan was initiated
    const scanStarted = response.status === 200 || response.status === 202;
    
    results['file_scan'] = testUtil.formatResult(
      'File-based vulnerability scan',
      scanStarted,
      !scanStarted ? 'Scan should be initiated successfully' : null
    );
    
    // If scan started, let's check if it found our intentional vulnerabilities
    if (scanStarted && response.data && response.data.results) {
      const vulnerabilities = response.data.results.vulnerabilities || [];
      
      // Check if our test vulnerabilities were detected
      const detectedVulnerabilities = config.testVulnerabilities.filter(testVuln => 
        vulnerabilities.some(v => v.id === testVuln.name || v.name === testVuln.name)
      );
      
      results['vulnerability_detection'] = testUtil.formatResult(
        'Test vulnerability detection',
        detectedVulnerabilities.length > 0,
        detectedVulnerabilities.length === 0 ? 
          'Known vulnerabilities should be detected' : null
      );
      
      // Check if severity levels are correctly reported
      if (detectedVulnerabilities.length > 0) {
        const hasSeverity = vulnerabilities.every(v => v.severity);
        
        results['severity_reporting'] = testUtil.formatResult(
          'Vulnerability severity reporting',
          hasSeverity,
          !hasSeverity ? 'All vulnerabilities should have severity levels' : null
        );
      }
    }
  } catch (error) {
    results['file_scan'] = testUtil.formatResult(
      'File-based vulnerability scan',
      false,
      error
    );
  } finally {
    // Clean up the test file
    if (testFilePath) {
      await testUtil.cleanupTestFiles();
    }
  }
  
  return results;
}

async function testPortScanDetection() {
  console.log('\n=== Port Scan Detection Test ===\n');
  const results = {};
  
  try {
    console.log('Testing port scan detection...');
    const client = testUtil.createApiClient();
    const scanParams = {
      target: 'localhost',
      scope: 'network',
      options: {
        port_scan: true,
        port_range: '3000-3010'  // Test a range of ports including our microservices
      }
    };
    
    const response = await client.post('/scan/ports', scanParams);
    
    // Check if the scan was initiated
    const scanStarted = response.status === 200 || response.status === 202;
    
    results['port_scan'] = testUtil.formatResult(
      'Port scan detection',
      scanStarted,
      !scanStarted ? 'Port scan should be initiated successfully' : null
    );
    
    // If we have immediate results, check if they found any open ports
    if (scanStarted && response.data && response.data.results) {
      const portsFound = response.data.results.open_ports || [];
      
      // Since we're targeting our own microservices, we should find at least one port
      results['ports_detected'] = testUtil.formatResult(
        'Ports detected',
        portsFound.length > 0,
        portsFound.length === 0 ? 'Should detect at least one open port' : null
      );
      
      console.log(`Detected ${portsFound.length} open ports`);
      portsFound.forEach(port => {
        console.log(`  - Port ${port.number}: ${port.service || 'Unknown service'}`);
      });
    }
  } catch (error) {
    results['port_scan'] = testUtil.formatResult(
      'Port scan detection',
      false,
      error
    );
  }
  
  return results;
}

async function testVulnerabilityScanScheduling() {
  console.log('\n=== Vulnerability Scan Scheduling Test ===\n');
  const results = {};
  
  try {
    console.log('Testing vulnerability scan scheduling...');
    const client = testUtil.createApiClient();
    const scheduleParams = {
      target: 'test-service',
      schedule: {
        frequency: 'daily',
        time: '03:00',
        timezone: 'UTC'
      },
      options: {
        dependency_check: true,
        port_scan: false
      }
    };
    
    const response = await client.post('/schedule', scheduleParams);
    
    // Check if the schedule was created
    const scheduleCreated = response.status === 200 || response.status === 201;
    const scheduleIdPresent = response.data && response.data.schedule_id;
    
    results['scan_scheduling'] = testUtil.formatResult(
      'Vulnerability scan scheduling',
      scheduleCreated && scheduleIdPresent,
      (!scheduleCreated || !scheduleIdPresent) ? 'Schedule should be created with an ID' : null
    );
    
    // If created, try to retrieve the schedule
    if (scheduleCreated && scheduleIdPresent) {
      const scheduleId = response.data.schedule_id;
      
      const getResponse = await client.get(`/schedule/${scheduleId}`);
      const scheduleExists = getResponse.status === 200 && getResponse.data;
      
      results['retrieve_schedule'] = testUtil.formatResult(
        'Retrieve scheduled scan',
        scheduleExists,
        !scheduleExists ? 'Should be able to retrieve the created schedule' : null
      );
      
      // Clean up by deleting the schedule
      if (scheduleExists) {
        await client.delete(`/schedule/${scheduleId}`);
      }
    }
  } catch (error) {
    results['scan_scheduling'] = testUtil.formatResult(
      'Vulnerability scan scheduling',
      false,
      error
    );
  }
  
  return results;
}

// Main test runner
async function runVulnerabilityTests() {
  console.log('===============================================');
  console.log('    Detailed Vulnerability Scanner Tests      ');
  console.log('===============================================\n');
  
  try {
    // Run tests in sequence
    const healthResults = await testVulnerabilityServiceHealth();
    const basicScanResults = await testBasicScan();
    
    // Only run results test if we have a scan ID from basic scan
    const scanResultsTest = await testScanResults(basicScanResults.scan_id);
    
    // Run other tests
    const fileBasedScanResults = await testFileBasedScan();
    const portScanResults = await testPortScanDetection();
    const schedulingResults = await testVulnerabilityScanScheduling();
    
    // Combine all results
    const allResults = {
      ...healthResults,
      ...basicScanResults,
      ...scanResultsTest,
      ...fileBasedScanResults,
      ...portScanResults,
      ...schedulingResults
    };
    
    // Count results
    let totalTests = 0;
    let passedTests = 0;
    let failedTests = 0;
    
    for (const key in allResults) {
      if (typeof allResults[key] === 'object' && allResults[key].hasOwnProperty('success')) {
        totalTests++;
        if (allResults[key].success) {
          passedTests++;
        } else {
          failedTests++;
        }
      }
    }
    
    // Print summary
    console.log('\n===============================================');
    console.log('        Vulnerability Tests Summary          ');
    console.log('===============================================');
    console.log(`Total Tests: ${totalTests}`);
    console.log(`Passed: ${passedTests}`);
    console.log(`Failed: ${failedTests}`);
    console.log(`Success Rate: ${(passedTests / totalTests * 100).toFixed(2)}%`);
    console.log('===============================================\n');
    
    return {
      health: healthResults,
      basicScan: basicScanResults,
      scanResults: scanResultsTest,
      fileBasedScan: fileBasedScanResults,
      portScan: portScanResults,
      scheduling: schedulingResults,
      summary: {
        totalTests,
        passedTests,
        failedTests,
        successRate: (passedTests / totalTests * 100).toFixed(2)
      }
    };
  } catch (error) {
    console.error('\n❌ Vulnerability test suite failed with error:', error.message);
    return { error };
  }
}

// Run the tests
if (require.main === module) {
  runVulnerabilityTests()
    .then(results => {
      // Exit with appropriate code based on test results
      if (results.error || (results.summary && results.summary.failedTests > 0)) {
        process.exit(1);
      } else {
        process.exit(0);
      }
    })
    .catch(err => {
      console.error('Unhandled error in vulnerability test suite:', err);
      process.exit(1);
    });
} else {
  // Export for use in other scripts
  module.exports = {
    runVulnerabilityTests,
    testVulnerabilityServiceHealth,
    testBasicScan,
    testScanResults,
    testFileBasedScan,
    testPortScanDetection,
    testVulnerabilityScanScheduling
  };
} 