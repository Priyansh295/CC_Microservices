"""
Mock scanner implementation for testing without external dependencies
"""
import json
import re
from .mock_data import NPM_VULNERABILITIES, PYTHON_VULNERABILITIES

class MockVulnerabilityScanner:
    """
    A mock implementation of the vulnerability scanner that uses predefined data
    instead of external tools like npm audit or safety.
    """
    
    @staticmethod
    def scan_npm_dependencies(package_content):
        """
        Scan package.json content for vulnerabilities using mock data
        """
        try:
            package_data = json.loads(package_content)
            dependencies = {
                **package_data.get("dependencies", {}),
                **package_data.get("devDependencies", {})
            }
            
            vulnerabilities = {
                "info": [],
                "low": [],
                "moderate": [],
                "high": [],
                "critical": []
            }
            
            for pkg_name, version in dependencies.items():
                if pkg_name in NPM_VULNERABILITIES:
                    for vuln in NPM_VULNERABILITIES[pkg_name]:
                        # Simple version check (in real world would use semver)
                        if MockVulnerabilityScanner._is_version_affected(version, vuln["affected_versions"]):
                            severity = vuln["severity"].lower()
                            if severity not in vulnerabilities:
                                severity = "moderate"  # fallback
                            
                            vulnerabilities[severity].append({
                                "name": pkg_name,
                                "version": version,
                                "title": vuln["title"],
                                "description": vuln["description"],
                                "recommendation": vuln["recommendation"],
                                "severity": severity,
                                "cve": vuln["id"]
                            })
            
            metadata = {
                "dependencies": len(dependencies),
                "devDependencies": len(package_data.get("devDependencies", {})),
                "totalDependencies": len(dependencies),
                "vulnerabilities": {
                    key: len(value) for key, value in vulnerabilities.items()
                }
            }
            
            return {
                "metadata": metadata,
                "vulnerabilities": vulnerabilities
            }
            
        except json.JSONDecodeError:
            return {"error": "Invalid package.json format"}
        except Exception as e:
            return {"error": str(e)}
    
    @staticmethod
    def scan_python_dependencies(requirements_content):
        """
        Scan requirements.txt content for vulnerabilities using mock data
        """
        try:
            # Parse requirements.txt
            dependencies = []
            for line in requirements_content.splitlines():
                line = line.strip()
                if line and not line.startswith('#'):
                    # Handle lines like "package==1.0.0" or "package>=1.0.0"
                    match = re.match(r'^([a-zA-Z0-9_\-]+)([<>=~!]+)([0-9a-zA-Z.]+)', line)
                    if match:
                        pkg_name, operator, version = match.groups()
                        dependencies.append({
                            "name": pkg_name,
                            "version": version,
                            "operator": operator
                        })
            
            vulnerabilities = []
            
            for dep in dependencies:
                pkg_name = dep["name"]
                if pkg_name in PYTHON_VULNERABILITIES:
                    for vuln in PYTHON_VULNERABILITIES[pkg_name]:
                        # Simple version check
                        if MockVulnerabilityScanner._is_version_affected(dep["version"], vuln["affected_versions"]):
                            vulnerabilities.append({
                                "package": pkg_name,
                                "version": dep["version"],
                                "id": vuln["id"],
                                "title": vuln["title"],
                                "description": vuln["description"],
                                "severity": vuln["severity"],
                                "recommendation": vuln["recommendation"]
                            })
            
            return {
                "dependencies": len(dependencies),
                "vulnerabilities": vulnerabilities
            }
            
        except Exception as e:
            return {"error": str(e)}
    
    @staticmethod
    def _is_version_affected(current_version, affected_range):
        """
        Very simplified version check. In real world, use proper semver comparison.
        
        For this mock, we'll handle only common patterns like:
        - <1.2.3 (less than 1.2.3)
        - <=1.2.3 (less than or equal to 1.2.3)
        - >=1.2.3 (greater than or equal to 1.2.3)
        """
        match = re.match(r'^([<>=]+)([0-9.]+)$', affected_range)
        if not match:
            return False
            
        operator, version = match.groups()
        
        # Convert versions to tuples of integers for comparison
        current = tuple(map(int, current_version.split('.')))
        target = tuple(map(int, version.split('.')))
        
        # Pad the shorter tuple with zeros
        max_len = max(len(current), len(target))
        current = current + (0,) * (max_len - len(current))
        target = target + (0,) * (max_len - len(target))
        
        if operator == "<":
            return current < target
        elif operator == "<=":
            return current <= target
        elif operator == ">":
            return current > target
        elif operator == ">=":
            return current >= target
        else:
            return False
    
    @staticmethod
    def calculate_risk_level(results):
        """Calculate risk level based on vulnerability count and severity"""
        if "error" in results:
            return "unknown"
        
        vuln_count = 0
        high_severity_count = 0
        
        # Handle npm audit format
        if "vulnerabilities" in results and isinstance(results["vulnerabilities"], dict):
            high_severity_count = len(results["vulnerabilities"].get("high", [])) + len(results["vulnerabilities"].get("critical", []))
            vuln_count = sum(len(vulns) for vulns in results["vulnerabilities"].values())
        
        # Handle safety check format
        elif "vulnerabilities" in results and isinstance(results["vulnerabilities"], list):
            vuln_count = len(results["vulnerabilities"])
            high_severity_count = sum(1 for v in results["vulnerabilities"] if v.get("severity", "").lower() in ["high", "critical"])
        
        if high_severity_count > 0:
            return "high"
        elif vuln_count > 10:
            return "high"
        elif vuln_count > 5:
            return "medium"
        elif vuln_count > 0:
            return "low"
        return "none" 